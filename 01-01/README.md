###### 1.结果

```
var a = [];
for (var i = 0; i < 10; i++) {
  a[i] = function () {
​    console.log(i)
  }
}
a[6]()
```

答案: 10;

分析:  var声明变量作用域为自身函数块/全局，

​			i为全局变量，代码运行后i = 10;a[6]中函数打印的i为全局变量i 

###### 2.结果

```
var tmp = 123;
if (true) {
  console.log(tmp);
  let tmp;
}
```

答案：报错

分析:  var声明变量,变量将提升至自身函数块/全局的顶部，未初始化值之前值为undefined;let声明变量，在其声明所在的块到变量定义被执行之前访问报错;块中tmp已定义但未执行，访问报错

###### 3.降序排列

```
var arr = [12, 34, 32, 89, 4];
```

答案:  `arr.reduce((max, num) => max > num ? max : num)`

###### 4.var/let/const 区别

- var变量声明; 声明提升至自身函数块或全局变量的顶部,未初始化值之前为undefined; 作用域为自身函数/全局; 同一变量可重复声明

- let 变量声明； 变量在声明时所在的块顶部到定义被执行之间不可访问;作用域为声明时所在的块；同一变量不可重复声明

- const 常量声明，声明时必须初始化值；常量在声明时所在的块顶部到定义被执行之间不可访问; 作用域为声明时所在的块；同一常量不可重复声明/赋值

###### 5.结果

```
var a = 10
var obj = {
  a: 20,
  fn() {
​    setTimeout(() => {
​      console.log(this.a)
​    })
  }
}
```

答案: 20

分析：箭头函数中的this从自己的作用域链上一层中继承；function如果是一个对象的方法，内部的this指向这个对象；`this.a = obj.a = 20`

###### 6.Symbol 类型用途

 唯一标识符，防止命名冲突。可以作为对象属性的标识符

###### 7.浅拷贝？深拷贝？

 基本数据类型：变量名/值存在栈中;引用数据类型,变量名/指针存在栈中，值存在堆中,指针指向值所在地址;

1. 深拷贝：拷贝变量的值，开辟新的堆内存，两个变量值之间不关
2. 浅拷贝：拷贝变量的指针，指向同一个值，堆中不开辟新的内存，修改一个变量会影响另一个变量

###### 8.js异步编程？EventLoop?宏任务？微任务？

同步模式中代码执行顺序自上而下，一个任务执行完，执行下一个任务（堵塞）；异步模式中代码执行顺序无须自上而下，一个任务未结束，不会影响下一个任务执行（非堵塞）

异步编程：异步模式执行，执行结束后，通过回调函数执行后续任务

EvenLoop:  js为单线程语言，通过EventLoop（事件循环）形式解决单线程堵塞问题（ 异步任务执行时不进入调用栈，执行结束后进入消息队列，同步任务执行结束后访问消息队列，执行异步任务返回结果（回调函数））

宏任务：执行结束后重新进入消息队列 (eg:setTimeout...)

微任务：优先级低于宏任务，所有宏任务执行结束后执行 (eg: Promise...)

###### 9.Promsie重写

```
setTimeout(function () {
  var a = "hello";
  setTimeout(function () {
​    var b = "lagou"
​    setTimeout(function () {
​      var c = "love"
​      console.log(a + b + c)
​    }, 10);
  }, 10);
}, 10)
```

答案： `Promise.resolve("hello").then(res => res + "lagou").then(res => res + "love").then(console.log)`

###### 10.TypeScript&JavaScript关系？

- TypeScript是Javascript的超集（js + es6+ + 类型系统）
- TypeScript代码编译为JavaScript执行

###### 11.TypeScript优缺点？

优点：

-  错误暴露早(编译阶段检查)
-  编码更智能/准确(强类型系统)
-  重构更牢靠(编译为JavaScript运行)
- ​ 减少不必要的类型判断(静态类型语言)

缺点： 

- 语言本身新增很多概念，增加学习成本
- 小型项目中使用，增加额外的开发成本（接口/类型声明）